<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>洪君瑞貪食蛇</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            background-color: #0f172a;
            touch-action: none;
            overflow: hidden;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        #game-canvas {
            image-rendering: pixelated;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
            max-width: 100%;
            max-height: 70vh;
            background-color: #1e293b;
        }
        .control-btn {
            -webkit-tap-highlight-color: transparent;
            user-select: none;
        }
        .control-btn:active {
            transform: scale(0.95);
            background-color: #334155;
        }
    </style>
</head>
<body class="flex flex-col items-center justify-center min-h-screen p-4 text-white">

    <div class="w-full max-w-md flex justify-between items-end mb-4">
        <div>
            <h1 class="text-3xl font-bold text-emerald-400">洪君瑞貪食蛇</h1>
            <p class="text-slate-400 text-sm">吃掉綠色方塊來成長</p>
        </div>
        <div class="text-right">
            <div class="text-xs uppercase tracking-wider text-slate-500">當前得分</div>
            <div id="score" class="text-2xl font-mono font-bold">0</div>
        </div>
    </div>

    <div class="relative bg-slate-800 p-2 rounded-xl border-4 border-slate-700">
        <canvas id="game-canvas"></canvas>
        
        <div id="game-over" class="hidden absolute inset-0 bg-slate-900/80 flex flex-col items-center justify-center rounded-lg backdrop-blur-sm">
            <h2 class="text-4xl font-black text-rose-500 mb-2">遊戲結束</h2>
            <p id="final-score-text" class="text-xl mb-6 text-slate-300">最終得分：0</p>
            <button id="restart-btn" class="bg-emerald-500 hover:bg-emerald-400 text-slate-900 px-8 py-3 rounded-full font-bold transition-all transform hover:scale-105">
                再玩一次
            </button>
        </div>
    </div>

    <div class="mt-4 text-slate-400 text-sm">
        最高紀錄: <span id="high-score" class="font-mono">0</span>
    </div>

    <div class="mt-8 grid grid-cols-3 gap-2 md:hidden">
        <div></div>
        <button id="btn-up" class="control-btn w-16 h-16 bg-slate-700 rounded-xl flex items-center justify-center text-2xl">▲</button>
        <div></div>
        <button id="btn-left" class="control-btn w-16 h-16 bg-slate-700 rounded-xl flex items-center justify-center text-2xl">◀</button>
        <button id="btn-down" class="control-btn w-16 h-16 bg-slate-700 rounded-xl flex items-center justify-center text-2xl">▼</button>
        <button id="btn-right" class="control-btn w-16 h-16 bg-slate-700 rounded-xl flex items-center justify-center text-2xl">▶</button>
    </div>

    <div class="mt-4 hidden md:block text-slate-500 text-sm">
        使用鍵盤方向鍵來移動
    </div>

    <script>
        const canvas = document.getElementById('game-canvas');
        const ctx = canvas.getContext('2d');
        const scoreElement = document.getElementById('score');
        const highScoreElement = document.getElementById('high-score');
        const gameOverScreen = document.getElementById('game-over');
        const finalScoreText = document.getElementById('final-score-text');
        const restartBtn = document.getElementById('restart-btn');

        // 遊戲設定
        const gridSize = 20;
        let tileCount = 20; 
        let score = 0;
        let highScore = 0;
        let gameLoop;
        let speed = 125;

        // 蛇與食物狀態
        let snake = [{ x: 10, y: 10 }];
        let food = { x: 5, y: 5 };
        let dx = 0;
        let dy = 0;
        let nextDx = 0;
        let nextDy = 0;

        function initCanvas() {
            // 確保畫布至少有 300px，避免 tileCount 變成 0
            const containerWidth = Math.max(Math.min(window.innerWidth - 40, 400), 300);
            canvas.width = containerWidth;
            canvas.height = containerWidth;
            tileCount = Math.floor(canvas.width / gridSize);
        }

        function startGame() {
            snake = [{ x: Math.floor(tileCount/2), y: Math.floor(tileCount/2) }];
            generateFood();
            score = 0;
            dx = 0;
            dy = 0;
            nextDx = 0;
            nextDy = 0;
            speed = 125;
            updateScore();
            gameOverScreen.classList.add('hidden');
            
            if (gameLoop) clearInterval(gameLoop);
            gameLoop = setInterval(draw, speed);
        }

        function generateFood() {
            food = {
                x: Math.floor(Math.random() * tileCount),
                y: Math.floor(Math.random() * tileCount)
            };
            // 確保食物不會生在蛇身上
            for (let part of snake) {
                if (part.x === food.x && part.y === food.y) {
                    return generateFood();
                }
            }
        }

        function draw() {
            dx = nextDx;
            dy = nextDy;

            if (dx !== 0 || dy !== 0) {
                const head = { x: snake[0].x + dx, y: snake[0].y + dy };

                // 邊界碰撞
                if (head.x < 0 || head.x >= tileCount || head.y < 0 || head.y >= tileCount) {
                    return gameOver();
                }

                // 身體碰撞
                for (let part of snake) {
                    if (head.x === part.x && head.y === part.y) {
                        return gameOver();
                    }
                }

                snake.unshift(head);

                // 吃到食物
                if (head.x === food.x && head.y === food.y) {
                    score += 10;
                    updateScore();
                    generateFood();
                    // 加速機制
                    if (score % 50 === 0 && speed > 60) {
                        clearInterval(gameLoop);
                        speed -= 5;
                        gameLoop = setInterval(draw, speed);
                    }
                } else {
                    snake.pop();
                }
            }

            // 背景
            ctx.fillStyle = '#1e293b'; 
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // 網格線
            ctx.strokeStyle = '#334155';
            ctx.lineWidth = 0.5;
            for(let i=0; i<=tileCount; i++) {
                ctx.beginPath(); ctx.moveTo(i*gridSize, 0); ctx.lineTo(i*gridSize, canvas.height); ctx.stroke();
                ctx.beginPath(); ctx.moveTo(0, i*gridSize); ctx.lineTo(canvas.width, i*gridSize); ctx.stroke();
            }

            // 食物 (使用 fillRect 確保相容性)
            ctx.fillStyle = '#10b981'; 
            ctx.fillRect(food.x * gridSize + 2, food.y * gridSize + 2, gridSize - 4, gridSize - 4);

            // 蛇
            snake.forEach((part, index) => {
                const isHead = index === 0;
                ctx.fillStyle = isHead ? '#fbbf24' : '#f59e0b'; 
                
                const padding = isHead ? 1 : 2;
                ctx.fillRect(
                    part.x * gridSize + padding, 
                    part.y * gridSize + padding, 
                    gridSize - padding*2, 
                    gridSize - padding*2
                );

                // 眼睛
                if (isHead && (dx !== 0 || dy !== 0)) {
                    ctx.fillStyle = 'black';
                    const eyeSize = 2;
                    if (dx === 1) {
                        ctx.fillRect(part.x * gridSize + 13, part.y * gridSize + 5, eyeSize, eyeSize);
                        ctx.fillRect(part.x * gridSize + 13, part.y * gridSize + 13, eyeSize, eyeSize);
                    } else if (dx === -1) {
                        ctx.fillRect(part.x * gridSize + 5, part.y * gridSize + 5, eyeSize, eyeSize);
                        ctx.fillRect(part.x * gridSize + 5, part.y * gridSize + 13, eyeSize, eyeSize);
                    } else if (dy === -1) {
                        ctx.fillRect(part.x * gridSize + 5, part.y * gridSize + 5, eyeSize, eyeSize);
                        ctx.fillRect(part.x * gridSize + 13, part.y * gridSize + 5, eyeSize, eyeSize);
                    } else if (dy === 1) {
                        ctx.fillRect(part.x * gridSize + 5, part.y * gridSize + 13, eyeSize, eyeSize);
                        ctx.fillRect(part.x * gridSize + 13, part.y * gridSize + 13, eyeSize, eyeSize);
                    }
                }
            });
        }

        function updateScore() {
            scoreElement.innerText = score;
            if (score > highScore) {
                highScore = score;
                highScoreElement.innerText = highScore;
            }
        }

        function gameOver() {
            clearInterval(gameLoop);
            finalScoreText.innerText = `最終得分：${score}`;
            gameOverScreen.classList.remove('hidden');
        }

        function handleInput(e) {
            const key = e.key;
            if (key === 'ArrowUp' && dy === 0) { nextDx = 0; nextDy = -1; }
            if (key === 'ArrowDown' && dy === 0) { nextDx = 0; nextDy = 1; }
            if (key === 'ArrowLeft' && dx === 0) { nextDx = -1; nextDy = 0; }
            if (key === 'ArrowRight' && dx === 0) { nextDx = 1; nextDy = 0; }
        }

        // 按鈕綁定
        document.getElementById('btn-up').onclick = () => { if(dy===0) {nextDx=0; nextDy=-1;} };
        document.getElementById('btn-down').onclick = () => { if(dy===0) {nextDx=0; nextDy=1;} };
        document.getElementById('btn-left').onclick = () => { if(dx===0) {nextDx=-1; nextDy=0;} };
        document.getElementById('btn-right').onclick = () => { if(dx===0) {nextDx=1; nextDy=0;} };

        window.addEventListener('keydown', handleInput);
        restartBtn.onclick = startGame;
        window.addEventListener('resize', () => {
            initCanvas();
            draw();
        });

        initCanvas();
        startGame();

    </script>
</body>
</html>
